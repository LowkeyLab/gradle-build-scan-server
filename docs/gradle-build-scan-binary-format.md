# Gradle Build Scan Binary Format

This document details the proprietary binary format used by Gradle (specifically the `com.gradle.develocity` / `com.gradle.enterprise` plugin) to serialize build scan telemetry when publishing to a Build Scan server.

## Upload Sequence

When a Gradle build runs with the `--scan` flag, it performs a multi-step handshake with the server (e.g., `scans.gradle.com` or a self-hosted instance).

1.  **Verification (`GET /usage/users/check`)**: Checks if the user is authenticated, has accepted the Terms of Service, and is allowed to publish build scans.
2.  **Token Request (`POST /scans/publish/gradle/{version}/token`)**: Requests an upload token. The payload is cleartext JSON:
    ```json
    {
      "buildToolType": "gradle",
      "buildToolVersion": "9.3.1",
      "buildAgentVersion": "4.3.2",
      "providedBuildId": "<random_id>",
      "payloadSize": 66822
    }
    ```
3.  **Scan Upload (`POST /scans/publish/gradle/{version}/upload`)**: Uploads the actual build scan telemetry using a custom binary format.

## Payload Structure

The build scan upload payload is a highly optimized, custom binary format designed to minimize network overhead and avoid slowing down the developer's build. It consists of two main parts:

### 1. Cleartext Header

The payload begins with a 28-byte uncompressed metadata header. This allows the server to identify the payload type and versions before allocating resources to decompress the body.

Example header:
```
\x28\xc5\x00\x02\x00\x16\x00\x06GRADLE\x00\x059.3.1\x00\x054.3.2
```
This contains the magic bytes, the tool identifier (`GRADLE`), the Gradle version (`9.3.1`), and the build scan plugin version (`4.3.2`).

### 2. Gzip Stream

Immediately following the cleartext header (at byte offset 28 in the above example), the payload transitions into a standard `gzip` compressed stream, identifiable by the `\x1f\x8b\x08` magic bytes.

### 3. Custom LEB128 Binary Protocol

Once decompressed, the inner stream reveals Gradle's custom binary encoding. It does not use standard formats like Protocol Buffers, JSON, or BSON. Instead, it is a bespoke, schema-less stream protocol.

Key characteristics:

*   **Schema-less Structure**: The stream is a tightly packed, ordered sequence of values without embedded field names or tags. The server must know the exact schema of the build events (which corresponds to the plugin version) to parse them correctly. It is essentially a continuous log of events: `[EventTypeID, TimeStampOffset, EventDataVarints...]`.
*   **LEB128 Varints**: Integers, longs (like timestamps in milliseconds since epoch), and sizes are encoded as Base-128 Varints (LEB128). This allows small numbers to consume only 1 byte while scaling up for larger values.
*   **Shifted String Lengths**: Strings are prefixed by a varint representing their length, but with a bit-shifting optimization. 
    *   The length varint is shifted left by 1: `length = varint >> 1`.
    *   The least significant bit (`varint & 1`) serves as a flag (e.g., `0` for standard ASCII, `1` for UTF-8 or a back-reference to an interned string to save space).
    *   Example: The string `"linux"` (5 bytes) is prefixed with `0x0A` (10 in decimal). `10 >> 1 = 5`, and `10 & 1 = 0`.

## Known Telemetry Fields

| Event ID | Name | Format Description | Examples |
| :--- | :--- | :--- | :--- |
| **2** | User/Host Information | `[Event ID 2] [Username String] [Hostname String]` (No payload length prefix, just two varint-length-prefixed strings back to back). | - |
| **3** | JVM Information | `[Event ID 3] [Payload Length Varint] [Payload bytes...]` | `"Arch Linux"`, `"OpenJDK Runtime Environment"`, `"25.0.2"` |
| **8** | OS Information | `[Event ID 8] [Payload Length Varint] [Payload bytes...]` | `"linux"`, `"6.18.7-arch1-1"` |
| **58** | Task Execution | `[Event ID 58] [Task Path String] [Payload bytes...]` | `":app:compileKotlin"` |

## Contained Information

Decoding the stream reveals highly detailed telemetry, including:

*   **Environment & System Details**: OS (Linux, Windows, kernel versions, architecture), JVM (vendor, version, runtime details like `mixed mode, sharing`).
*   **Task Execution Graph**: References to configured tasks (e.g., `:app:compileKotlin`), task classes (`org.jetbrains.kotlin.gradle.tasks.KotlinCompile`), and execution metrics (offsets, durations).
*   **Build Cache Information**: Cryptographic cache keys (e.g., `wie7xopejfda3k2fm57fy5fgni`) generated by hashing task inputs.
*   **Timestamps**: Exact event execution timestamps encoded as milliseconds since the Unix epoch.

## Reverse-Engineering Session Notes (2026-02-21)

* The Gradle scan URL used: `https://gradle.com/s/3j4tact635rx2`
* Gradle version 9.3.1, Develocity plugin 4.3.2
* We used Chrome UI to catalog string anchors (e.g. `linux`, `tacascer`, `:app:compileKotlin`)
* We searched the decompressed binary and identified that complex events like OS (8) and JVM (3) are wrapped in a payload length varint, while simple structural events like User/Host (2) and Task (58) immediately follow the event ID with their respective string varints.
* We modified the parser to correctly skip these events based on their length structure, but encountered new unknown events (`3543269142742` and `9`). The parser requires exact structural knowledge of every event ID to successfully reach the end of the file.
